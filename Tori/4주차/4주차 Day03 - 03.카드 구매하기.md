---
tags:
  - 다이나믹프로그래밍
링크: https://www.acmicpc.net/problem/11052
Status: "#풀이 완료"
문제풀이날짜: ""
---
# 카드 구매하기
## 문제 설명
- 문제 제목 (사이트) : 카드 구매하기(백준)
- 문제 링크 : https://www.acmicpc.net/problem/11052
- 난이도(백준 티어, 프로그래머스 레벨) : 실버1

## 문제 풀이
### 문제 내용 정리
- 카드에는 등급이 있고, 카드팩의 종류는 카드 1개가 포함된 카드팩, 카드 2개가 포함된 카드팩, ... 카드 N개가 포함된 카드팩과 같이 총 N가지가 존재
- 각 카드팩의 가격이 주어질 때 돈을 최대한 많이 지불하여 N개의 카드를 뽑을 때 지불하는 돈 출력
ex) N = 4, P1 = 1, P2 = 5, P3 = 6, P4 = 7 일 때 돈을 최대한 많이 지불하여 4개의 카드를 뽑는 방법은 P2 두개를 구매하여 10을 지불하는 방법임

### 문제 유형
- 조합 -> 이는 너무 많은 경우의 수가 나올 수 있어 시간초과를 초래할것이라 판단
- 다이나믹프로그래밍

### 풀이 방법
2차원 DP배열 이용
- 배열의 행은 N개를 뽑는 경우를 의미
- 배열의 열은 Pi 를 구매하여 뽑는 경우를 의미
- 즉 i행 j열의 의미는 Pj를 이용하여 카드 i개를 뽑은 최대 비용을 의미한다.

이때 행부터 순회하여 해당 열을 i열이라 할때 i개의 카드를 뽑는 경우의 수를 P1~Pn까지 사용한 경우로 나누어 차례로 구함 -> 카드 i개를 뽑는 모든 경우의 수임
따라서 열 i에 대하여 모든 행을 순회하면 카드 i개를 뽑는 최대 비용을 알 수 있음 -> i열의 최대값을 구하면됨

`dp[i][j]`는 j 카드팩을 꼭 이용해야하므로 = j카드팩의 비용 + (구해야하는 카드 i개 - j 개)의 카드를 구매하는 최대값  = `dp[i][j] = j카드팩 비용 + dp[i-j]의 최대값`
이때 i-j의 최대값은 dp i-j열의 최댓값을 의미하며 이는 i보다 작은 수이므로 이미 순차적으로 진행하여 dp가 구해져있음

### 예외 상황 및 고려 사항 (선택)
- i-j열의 최댓값을 구하는 시간복잡도는 O(N)임 -> i-j열의 수가 N이므로 
  이를 2차원 배열의 원소를 하나씩 접근할때마다 최대값 연산을 호출하는 것은 시간복잡도 낭비라고 판단하여
  카드 n개 뽑기의 최대값을 기록해두는 maxDp 배열을 하나 더 만들어 값을 구할때마다 갱신하여 최대값연산을 하지않도록 함
### 소스 코드
```swift
let n = Int(readLine()!)!
let prices = readLine()!.split(separator: " ").map{Int($0)!}

var dp = [[Int]](repeating: [Int](repeating: 0, count: n+1), count: n+1) // dp[y][x] 는 Px를 사용해서 y개 뽑기 최대값
var maxDp = [Int](repeating: 0, count: n+1) // n개 뽑기 max 기록

for y in 1...n {
    for x in 1...n { // x축(행) 부터 순회하기
        if x > y { continue } // x가 y보다 크다는 것은 y보다 큰 갯수가 들어있는 카드팩을 이용해 카드 y개를 뽑는 것이므로 성립 X
        dp[y][x] = prices[x-1] + maxDp[y-x]
        // prices는 인덱스가 1개씩 작음(x-1)
        // dp[y][x]는 카드팩 x를 사용해서 y개를 만드는 것이므로 x팩은 꼭 사야함. 따라서 prices[x-1]
        // 남은 카드 y-x개는 이전 dp에 저장된 최대값을 참조 -> 반복되는 max연산을 피하기 위해 maxDp를 만들어 y개 카드 뽑기의 max를 기록해둔 것
        maxDp[y] = max(maxDp[y], dp[y][x]) // 새로 구한 x에 대해서 maxDp 갱신하기
    }
}

print(maxDp[n])

```