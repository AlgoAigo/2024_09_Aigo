# 쉬운 계단 수
## 문제 설명
- 문제 제목 (사이트) : 쉬운 계단수 (백준)
- 문제 링크 : https://www.acmicpc.net/problem/10844
- 난이도(백준 티어, 프로그래머스 레벨) : 실버1

## 문제 풀이
### 문제 내용 정리
계단수란 인접한 모든 자리의 차이가 1인 수
ex) 45656
N이 주어질 때 길이가 N인 계단 수 구하기

### 문제 유형
- 다이나믹 프로그래밍

### 풀이 방법
2차원 DP 배열을 생성하여 각 행과 열은 다음을 의미하게 한다.
- 행은 0~9까지의 범위로 설정하고  i번째 행은 숫자 i로 끝나는 계단수를 의미한다.
- 열은 0~n까지의 범위로 설정하고 i번째 열은 길이가 i인 계단수를 의미한다. (단 길이가 0일 수는 없으므로 0열은 값 0으로 넣어 무시한다.)
즉 dp의 i열 j행은 길이가 i이면서 숫자 j로 끝나는 계단수의 갯수를 의미함
따라서 길이가 i인 계단 수는 i열의 모든 수를 더한 값 => `[i][0] + [i][1] + [i][2] + ... [i][9]`
### 예외 상황 및 고려 사항 (선택)
- 길이가 1인 계단수는 0부터 시작할 수 없으므로 0열은 무시하고 1~9까지의 열이 각 1개씩 차지하여 총 9개임
### 소스 코드
```swift
let n = Int(readLine()!)!
var dp = [[Int]](repeating: [Int](repeating: 0, count: 10), count: n+1)
// 행 0~9 는 숫자 i으로 끝나는 계단수
// 열 1~n 은 길이가 n인 계단 수, 0은 비우기
// 즉 dp[열][행] = 행으로 끝나면서 길이가 열인 계단 수의 갯수
for i in 1...9 { // 첫번째 숫자로 0이 올 수 없으므로 1부터 시작
    dp[1][i] = 1 // 길이가 1인 계단수는 어떠한 숫자로 끝나든 1개
}

if n > 1 {
    for i in 2...n { // 길이 2부터 시작해서 n까지 찾기
        for j in 0...9 { // 끝자리 0~9
            if j == 0 { // 만약 끝자리가 0으로 끝난다면 앞의 수는 1만 올 수 있음
                dp[i][j] = dp[i-1][1] % 1000000000 
                // 따라서 n-1길이까지 끝자리가 1인 수 + 0이 됨 = dp[i-1][1]개
            } else if j == 9 { // 끝자리가 9 라면 앞의 수는 8만 가능
                dp[i][j] = dp[i-1][8] % 1000000000
                // 따라서 n-1길이까지 끝자리가 8인 수 + 9 = dp[i-1][9]개
            } else {
            // 그 외에는 -1, +1 한 숫자들이 올 수 있음
            // -1한 수가 오는 경우의 수 + +1한 수가 오는 경우의 수
                dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1] % 1000000000
            }
        }
    }
}

let result = dp[n].reduce(0) { $0 + $1 } % 1000000000
// 결과는 길이가 n인 수에서 끝자리가 0~9로끝나는 경우 모두 더해줌. 즉 dp[n]의 값을 모두 더함
print(result)

```

#### 시간 복잡도
- 길이 1~n만큼 반복하면서 0~9까지 10개의 숫자를 살펴봄
- 즉 n * 10 번 반복 -> **O(n * 10) = O(n)**