---
tags:
  - BFS
링크: https://www.acmicpc.net/problem/2468
Status: "#풀이 완료"
문제풀이날짜: 2024-09-25
---
# 안전 영역
## 문제 설명
- 문제 제목 (사이트) : 안전 영역 (백준) 
- 문제 링크 : https://www.acmicpc.net/problem/2468
- 난이도(백준 티어, 프로그래머스 레벨) : 실버 1

## 문제 풀이
### 문제 내용 정리
- 지역의 높이정보를 표시한 2차원 배열이 map 이 있을 때 일정 높이만큼의 비가오면 잠기지않는 안전한 영역을 파악하기
- 상하좌우로 붙어있는 곳을 이어져있다고 할 때 물에 잠기지않은 영역중 이어진 한 구역을 안전 영역이라 할 때 
- 내리는 비의 양에 따른 모든 경우를 다 조사해 장마철에 물에 잠기지않는 안전영역의 최대갯수 구하기

### 문제 유형
- BFS

### 풀이 방법
- 지역의 최대 높이를 구하여 최대높이까지 모든 높이에 대해 bfs를 이용하여 안전 영역 갯수 구하기
  (지역의 최대높이만큼 비가오게되면 모든 곳이 잠기므로 범위는 0..<최대높이)

### 예외 상황 및 고려 사항 (선택)
- 처음에는 비가 안오는 경우의 수를 제외하여 1..<최대 높이까지 범위로 설정하여 제출하였으나 이는 마지막 테스트 케이스를 실패함
- 따라서 비가안오는 경우의 수도 포함하여 계산해야함

### 소스 코드
```swift
typealias Position = (x: Int, y: Int)
let n = Int(readLine()!)!
var map = [[Int]]()
for _ in 1...n { //지역 높이정보 입력받기
    map.append(readLine()!.split(separator: " ").map{Int($0)!})
}

func findSafeArea(rainHeight: Int) -> Int {
// 입력받은 높이만큼 비가 올때 안전영역의 수를 반환하는 함수
    var count = 0 // 안전영역 카운팅 변수
    var visited = [[Bool]](repeating: [Bool](repeating: false, count: n), count: n) // 방문 배열 -> 높이 설정을 바꿀 때마다 초기화 될 수 있도록 해당 함수안에서 선언
    
    func bfs(_ start: Position) { 
    // 현재 **findSafeArea** 함수의 설정을 가지고 한개의 안전영역을 찾기 위한 bfs 함수
        var queue = [Position]()
        let moves: [Position] = [(1,0), (0,1), (-1,0), (0, -1)]
        queue.append(start)

        var index = 0
        while queue.count > index {
            let node = queue[index]
            index += 1
            if visited[node.y][node.x] || map[node.y][node.x] <= rainHeight {
                continue
            }
            
            visited[node.y][node.x] = true
            
            for move in moves {
            // 연결된 다음 좌표들
                let nx = node.x + move.x
                let ny = node.y + move.y
                
                if 0..<n ~= nx && 0..<n ~= ny && !visited[ny][nx] && map[ny][nx] > rainHeight { // 다음 좌표가 범위안에 포함되며 방문하지않았고, 빗물에 잠기지않는 높이라면
                    queue.append((nx, ny))
                }
            }
        }
    }
    
    for x in 0..<n {
        for y in 0..<n {
        // 모든 좌표를 순회하며 안전구역을 구함
            if !visited[y][x] && map[y][x] > rainHeight {
            // 새로운 방문하지않고 빗물에 잠기지않는 영역을 발견하면 인접한 안전 영역을 visited 표시하고 안전영역 수를 1 올려줌
                count += 1
                bfs((x,y))
            }
        }
    }
    return count
}

let maxHeight = map.flatMap({ $0 }).max()! // 2차원 배열을 1차원 배열로 변환 후 최대 높이 구하기
var maxCount = 0
for i in 0..<maxHeight { 
// 현재 계산하는 비의 양 = i 
// i만큼 비가 왔을 때 안전영역의 수를 구하여 현재까지 갱신된 최대 갯수와 비교하여 최댓값 갱신하기
    maxCount = max(maxCount, findSafeArea(rainHeight: i))
}
print(maxCount)

```